// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	coupon "github.com/chisdev/coupon/api"
	entcoupon "github.com/chisdev/coupon/pkg/ent/coupon"
	"github.com/chisdev/coupon/pkg/ent/currency"
	"github.com/chisdev/coupon/pkg/ent/milestone"
	"github.com/chisdev/coupon/pkg/ent/predicate"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCoupon    = "Coupon"
	TypeCurrency  = "Currency"
	TypeMilestone = "Milestone"
)

// CouponMutation represents an operation that mutates the Coupon nodes in the graph.
type CouponMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	code              *string
	value             *float64
	addvalue          *float64
	store_id          *string
	expire_at         *time.Time
	customer_id       *string
	service_ids       *[]string
	appendservice_ids []string
	_type             *coupon.CouponType
	add_type          *coupon.CouponType
	usage_limit       *int32
	addusage_limit    *int32
	used_count        *int32
	addused_count     *int32
	status            *coupon.CouponStatus
	addstatus         *coupon.CouponStatus
	reserved_count    *int32
	addreserved_count *int32
	clearedFields     map[string]struct{}
	currency          *uint64
	clearedcurrency   bool
	done              bool
	oldValue          func(context.Context) (*Coupon, error)
	predicates        []predicate.Coupon
}

var _ ent.Mutation = (*CouponMutation)(nil)

// couponOption allows management of the mutation configuration using functional options.
type couponOption func(*CouponMutation)

// newCouponMutation creates new mutation for the Coupon entity.
func newCouponMutation(c config, op Op, opts ...couponOption) *CouponMutation {
	m := &CouponMutation{
		config:        c,
		op:            op,
		typ:           TypeCoupon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponID sets the ID field of the mutation.
func withCouponID(id uint64) couponOption {
	return func(m *CouponMutation) {
		var (
			err   error
			once  sync.Once
			value *Coupon
		)
		m.oldValue = func(ctx context.Context) (*Coupon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Coupon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCoupon sets the old Coupon of the mutation.
func withCoupon(node *Coupon) couponOption {
	return func(m *CouponMutation) {
		m.oldValue = func(context.Context) (*Coupon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Coupon entities.
func (m *CouponMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CouponMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Coupon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CouponMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CouponMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CouponMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CouponMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CouponMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CouponMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCode sets the "code" field.
func (m *CouponMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CouponMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CouponMutation) ResetCode() {
	m.code = nil
}

// SetValue sets the "value" field.
func (m *CouponMutation) SetValue(f float64) {
	m.value = &f
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *CouponMutation) Value() (r float64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "value" field.
func (m *CouponMutation) AddValue(f float64) {
	if m.addvalue != nil {
		*m.addvalue += f
	} else {
		m.addvalue = &f
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *CouponMutation) AddedValue() (r float64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *CouponMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetStoreID sets the "store_id" field.
func (m *CouponMutation) SetStoreID(s string) {
	m.store_id = &s
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *CouponMutation) StoreID() (r string, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldStoreID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *CouponMutation) ResetStoreID() {
	m.store_id = nil
}

// SetExpireAt sets the "expire_at" field.
func (m *CouponMutation) SetExpireAt(t time.Time) {
	m.expire_at = &t
}

// ExpireAt returns the value of the "expire_at" field in the mutation.
func (m *CouponMutation) ExpireAt() (r time.Time, exists bool) {
	v := m.expire_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireAt returns the old "expire_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldExpireAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireAt: %w", err)
	}
	return oldValue.ExpireAt, nil
}

// ClearExpireAt clears the value of the "expire_at" field.
func (m *CouponMutation) ClearExpireAt() {
	m.expire_at = nil
	m.clearedFields[entcoupon.FieldExpireAt] = struct{}{}
}

// ExpireAtCleared returns if the "expire_at" field was cleared in this mutation.
func (m *CouponMutation) ExpireAtCleared() bool {
	_, ok := m.clearedFields[entcoupon.FieldExpireAt]
	return ok
}

// ResetExpireAt resets all changes to the "expire_at" field.
func (m *CouponMutation) ResetExpireAt() {
	m.expire_at = nil
	delete(m.clearedFields, entcoupon.FieldExpireAt)
}

// SetCustomerID sets the "customer_id" field.
func (m *CouponMutation) SetCustomerID(s string) {
	m.customer_id = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *CouponMutation) CustomerID() (r string, exists bool) {
	v := m.customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCustomerID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ClearCustomerID clears the value of the "customer_id" field.
func (m *CouponMutation) ClearCustomerID() {
	m.customer_id = nil
	m.clearedFields[entcoupon.FieldCustomerID] = struct{}{}
}

// CustomerIDCleared returns if the "customer_id" field was cleared in this mutation.
func (m *CouponMutation) CustomerIDCleared() bool {
	_, ok := m.clearedFields[entcoupon.FieldCustomerID]
	return ok
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *CouponMutation) ResetCustomerID() {
	m.customer_id = nil
	delete(m.clearedFields, entcoupon.FieldCustomerID)
}

// SetServiceIds sets the "service_ids" field.
func (m *CouponMutation) SetServiceIds(s []string) {
	m.service_ids = &s
	m.appendservice_ids = nil
}

// ServiceIds returns the value of the "service_ids" field in the mutation.
func (m *CouponMutation) ServiceIds() (r []string, exists bool) {
	v := m.service_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceIds returns the old "service_ids" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldServiceIds(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceIds: %w", err)
	}
	return oldValue.ServiceIds, nil
}

// AppendServiceIds adds s to the "service_ids" field.
func (m *CouponMutation) AppendServiceIds(s []string) {
	m.appendservice_ids = append(m.appendservice_ids, s...)
}

// AppendedServiceIds returns the list of values that were appended to the "service_ids" field in this mutation.
func (m *CouponMutation) AppendedServiceIds() ([]string, bool) {
	if len(m.appendservice_ids) == 0 {
		return nil, false
	}
	return m.appendservice_ids, true
}

// ResetServiceIds resets all changes to the "service_ids" field.
func (m *CouponMutation) ResetServiceIds() {
	m.service_ids = nil
	m.appendservice_ids = nil
}

// SetType sets the "type" field.
func (m *CouponMutation) SetType(ct coupon.CouponType) {
	m._type = &ct
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *CouponMutation) GetType() (r coupon.CouponType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldType(ctx context.Context) (v coupon.CouponType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds ct to the "type" field.
func (m *CouponMutation) AddType(ct coupon.CouponType) {
	if m.add_type != nil {
		*m.add_type += ct
	} else {
		m.add_type = &ct
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *CouponMutation) AddedType() (r coupon.CouponType, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *CouponMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetCurrencyID sets the "currency_id" field.
func (m *CouponMutation) SetCurrencyID(u uint64) {
	m.currency = &u
}

// CurrencyID returns the value of the "currency_id" field in the mutation.
func (m *CouponMutation) CurrencyID() (r uint64, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrencyID returns the old "currency_id" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCurrencyID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrencyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrencyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrencyID: %w", err)
	}
	return oldValue.CurrencyID, nil
}

// ClearCurrencyID clears the value of the "currency_id" field.
func (m *CouponMutation) ClearCurrencyID() {
	m.currency = nil
	m.clearedFields[entcoupon.FieldCurrencyID] = struct{}{}
}

// CurrencyIDCleared returns if the "currency_id" field was cleared in this mutation.
func (m *CouponMutation) CurrencyIDCleared() bool {
	_, ok := m.clearedFields[entcoupon.FieldCurrencyID]
	return ok
}

// ResetCurrencyID resets all changes to the "currency_id" field.
func (m *CouponMutation) ResetCurrencyID() {
	m.currency = nil
	delete(m.clearedFields, entcoupon.FieldCurrencyID)
}

// SetUsageLimit sets the "usage_limit" field.
func (m *CouponMutation) SetUsageLimit(i int32) {
	m.usage_limit = &i
	m.addusage_limit = nil
}

// UsageLimit returns the value of the "usage_limit" field in the mutation.
func (m *CouponMutation) UsageLimit() (r int32, exists bool) {
	v := m.usage_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageLimit returns the old "usage_limit" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldUsageLimit(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageLimit: %w", err)
	}
	return oldValue.UsageLimit, nil
}

// AddUsageLimit adds i to the "usage_limit" field.
func (m *CouponMutation) AddUsageLimit(i int32) {
	if m.addusage_limit != nil {
		*m.addusage_limit += i
	} else {
		m.addusage_limit = &i
	}
}

// AddedUsageLimit returns the value that was added to the "usage_limit" field in this mutation.
func (m *CouponMutation) AddedUsageLimit() (r int32, exists bool) {
	v := m.addusage_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageLimit resets all changes to the "usage_limit" field.
func (m *CouponMutation) ResetUsageLimit() {
	m.usage_limit = nil
	m.addusage_limit = nil
}

// SetUsedCount sets the "used_count" field.
func (m *CouponMutation) SetUsedCount(i int32) {
	m.used_count = &i
	m.addused_count = nil
}

// UsedCount returns the value of the "used_count" field in the mutation.
func (m *CouponMutation) UsedCount() (r int32, exists bool) {
	v := m.used_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedCount returns the old "used_count" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldUsedCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedCount: %w", err)
	}
	return oldValue.UsedCount, nil
}

// AddUsedCount adds i to the "used_count" field.
func (m *CouponMutation) AddUsedCount(i int32) {
	if m.addused_count != nil {
		*m.addused_count += i
	} else {
		m.addused_count = &i
	}
}

// AddedUsedCount returns the value that was added to the "used_count" field in this mutation.
func (m *CouponMutation) AddedUsedCount() (r int32, exists bool) {
	v := m.addused_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsedCount resets all changes to the "used_count" field.
func (m *CouponMutation) ResetUsedCount() {
	m.used_count = nil
	m.addused_count = nil
}

// SetStatus sets the "status" field.
func (m *CouponMutation) SetStatus(cs coupon.CouponStatus) {
	m.status = &cs
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CouponMutation) Status() (r coupon.CouponStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldStatus(ctx context.Context) (v coupon.CouponStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds cs to the "status" field.
func (m *CouponMutation) AddStatus(cs coupon.CouponStatus) {
	if m.addstatus != nil {
		*m.addstatus += cs
	} else {
		m.addstatus = &cs
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CouponMutation) AddedStatus() (r coupon.CouponStatus, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CouponMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetReservedCount sets the "reserved_count" field.
func (m *CouponMutation) SetReservedCount(i int32) {
	m.reserved_count = &i
	m.addreserved_count = nil
}

// ReservedCount returns the value of the "reserved_count" field in the mutation.
func (m *CouponMutation) ReservedCount() (r int32, exists bool) {
	v := m.reserved_count
	if v == nil {
		return
	}
	return *v, true
}

// OldReservedCount returns the old "reserved_count" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldReservedCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReservedCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReservedCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReservedCount: %w", err)
	}
	return oldValue.ReservedCount, nil
}

// AddReservedCount adds i to the "reserved_count" field.
func (m *CouponMutation) AddReservedCount(i int32) {
	if m.addreserved_count != nil {
		*m.addreserved_count += i
	} else {
		m.addreserved_count = &i
	}
}

// AddedReservedCount returns the value that was added to the "reserved_count" field in this mutation.
func (m *CouponMutation) AddedReservedCount() (r int32, exists bool) {
	v := m.addreserved_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetReservedCount resets all changes to the "reserved_count" field.
func (m *CouponMutation) ResetReservedCount() {
	m.reserved_count = nil
	m.addreserved_count = nil
}

// ClearCurrency clears the "currency" edge to the Currency entity.
func (m *CouponMutation) ClearCurrency() {
	m.clearedcurrency = true
	m.clearedFields[entcoupon.FieldCurrencyID] = struct{}{}
}

// CurrencyCleared reports if the "currency" edge to the Currency entity was cleared.
func (m *CouponMutation) CurrencyCleared() bool {
	return m.CurrencyIDCleared() || m.clearedcurrency
}

// CurrencyIDs returns the "currency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CurrencyID instead. It exists only for internal usage by the builders.
func (m *CouponMutation) CurrencyIDs() (ids []uint64) {
	if id := m.currency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCurrency resets all changes to the "currency" edge.
func (m *CouponMutation) ResetCurrency() {
	m.currency = nil
	m.clearedcurrency = false
}

// Where appends a list predicates to the CouponMutation builder.
func (m *CouponMutation) Where(ps ...predicate.Coupon) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CouponMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CouponMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Coupon, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CouponMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CouponMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Coupon).
func (m *CouponMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, entcoupon.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entcoupon.FieldUpdatedAt)
	}
	if m.code != nil {
		fields = append(fields, entcoupon.FieldCode)
	}
	if m.value != nil {
		fields = append(fields, entcoupon.FieldValue)
	}
	if m.store_id != nil {
		fields = append(fields, entcoupon.FieldStoreID)
	}
	if m.expire_at != nil {
		fields = append(fields, entcoupon.FieldExpireAt)
	}
	if m.customer_id != nil {
		fields = append(fields, entcoupon.FieldCustomerID)
	}
	if m.service_ids != nil {
		fields = append(fields, entcoupon.FieldServiceIds)
	}
	if m._type != nil {
		fields = append(fields, entcoupon.FieldType)
	}
	if m.currency != nil {
		fields = append(fields, entcoupon.FieldCurrencyID)
	}
	if m.usage_limit != nil {
		fields = append(fields, entcoupon.FieldUsageLimit)
	}
	if m.used_count != nil {
		fields = append(fields, entcoupon.FieldUsedCount)
	}
	if m.status != nil {
		fields = append(fields, entcoupon.FieldStatus)
	}
	if m.reserved_count != nil {
		fields = append(fields, entcoupon.FieldReservedCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entcoupon.FieldCreatedAt:
		return m.CreatedAt()
	case entcoupon.FieldUpdatedAt:
		return m.UpdatedAt()
	case entcoupon.FieldCode:
		return m.Code()
	case entcoupon.FieldValue:
		return m.Value()
	case entcoupon.FieldStoreID:
		return m.StoreID()
	case entcoupon.FieldExpireAt:
		return m.ExpireAt()
	case entcoupon.FieldCustomerID:
		return m.CustomerID()
	case entcoupon.FieldServiceIds:
		return m.ServiceIds()
	case entcoupon.FieldType:
		return m.GetType()
	case entcoupon.FieldCurrencyID:
		return m.CurrencyID()
	case entcoupon.FieldUsageLimit:
		return m.UsageLimit()
	case entcoupon.FieldUsedCount:
		return m.UsedCount()
	case entcoupon.FieldStatus:
		return m.Status()
	case entcoupon.FieldReservedCount:
		return m.ReservedCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entcoupon.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entcoupon.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entcoupon.FieldCode:
		return m.OldCode(ctx)
	case entcoupon.FieldValue:
		return m.OldValue(ctx)
	case entcoupon.FieldStoreID:
		return m.OldStoreID(ctx)
	case entcoupon.FieldExpireAt:
		return m.OldExpireAt(ctx)
	case entcoupon.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case entcoupon.FieldServiceIds:
		return m.OldServiceIds(ctx)
	case entcoupon.FieldType:
		return m.OldType(ctx)
	case entcoupon.FieldCurrencyID:
		return m.OldCurrencyID(ctx)
	case entcoupon.FieldUsageLimit:
		return m.OldUsageLimit(ctx)
	case entcoupon.FieldUsedCount:
		return m.OldUsedCount(ctx)
	case entcoupon.FieldStatus:
		return m.OldStatus(ctx)
	case entcoupon.FieldReservedCount:
		return m.OldReservedCount(ctx)
	}
	return nil, fmt.Errorf("unknown Coupon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entcoupon.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entcoupon.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entcoupon.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case entcoupon.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case entcoupon.FieldStoreID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case entcoupon.FieldExpireAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireAt(v)
		return nil
	case entcoupon.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case entcoupon.FieldServiceIds:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceIds(v)
		return nil
	case entcoupon.FieldType:
		v, ok := value.(coupon.CouponType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case entcoupon.FieldCurrencyID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrencyID(v)
		return nil
	case entcoupon.FieldUsageLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageLimit(v)
		return nil
	case entcoupon.FieldUsedCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedCount(v)
		return nil
	case entcoupon.FieldStatus:
		v, ok := value.(coupon.CouponStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case entcoupon.FieldReservedCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReservedCount(v)
		return nil
	}
	return fmt.Errorf("unknown Coupon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, entcoupon.FieldValue)
	}
	if m.add_type != nil {
		fields = append(fields, entcoupon.FieldType)
	}
	if m.addusage_limit != nil {
		fields = append(fields, entcoupon.FieldUsageLimit)
	}
	if m.addused_count != nil {
		fields = append(fields, entcoupon.FieldUsedCount)
	}
	if m.addstatus != nil {
		fields = append(fields, entcoupon.FieldStatus)
	}
	if m.addreserved_count != nil {
		fields = append(fields, entcoupon.FieldReservedCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case entcoupon.FieldValue:
		return m.AddedValue()
	case entcoupon.FieldType:
		return m.AddedType()
	case entcoupon.FieldUsageLimit:
		return m.AddedUsageLimit()
	case entcoupon.FieldUsedCount:
		return m.AddedUsedCount()
	case entcoupon.FieldStatus:
		return m.AddedStatus()
	case entcoupon.FieldReservedCount:
		return m.AddedReservedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponMutation) AddField(name string, value ent.Value) error {
	switch name {
	case entcoupon.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case entcoupon.FieldType:
		v, ok := value.(coupon.CouponType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case entcoupon.FieldUsageLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageLimit(v)
		return nil
	case entcoupon.FieldUsedCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsedCount(v)
		return nil
	case entcoupon.FieldStatus:
		v, ok := value.(coupon.CouponStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case entcoupon.FieldReservedCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReservedCount(v)
		return nil
	}
	return fmt.Errorf("unknown Coupon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entcoupon.FieldExpireAt) {
		fields = append(fields, entcoupon.FieldExpireAt)
	}
	if m.FieldCleared(entcoupon.FieldCustomerID) {
		fields = append(fields, entcoupon.FieldCustomerID)
	}
	if m.FieldCleared(entcoupon.FieldCurrencyID) {
		fields = append(fields, entcoupon.FieldCurrencyID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponMutation) ClearField(name string) error {
	switch name {
	case entcoupon.FieldExpireAt:
		m.ClearExpireAt()
		return nil
	case entcoupon.FieldCustomerID:
		m.ClearCustomerID()
		return nil
	case entcoupon.FieldCurrencyID:
		m.ClearCurrencyID()
		return nil
	}
	return fmt.Errorf("unknown Coupon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponMutation) ResetField(name string) error {
	switch name {
	case entcoupon.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entcoupon.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entcoupon.FieldCode:
		m.ResetCode()
		return nil
	case entcoupon.FieldValue:
		m.ResetValue()
		return nil
	case entcoupon.FieldStoreID:
		m.ResetStoreID()
		return nil
	case entcoupon.FieldExpireAt:
		m.ResetExpireAt()
		return nil
	case entcoupon.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case entcoupon.FieldServiceIds:
		m.ResetServiceIds()
		return nil
	case entcoupon.FieldType:
		m.ResetType()
		return nil
	case entcoupon.FieldCurrencyID:
		m.ResetCurrencyID()
		return nil
	case entcoupon.FieldUsageLimit:
		m.ResetUsageLimit()
		return nil
	case entcoupon.FieldUsedCount:
		m.ResetUsedCount()
		return nil
	case entcoupon.FieldStatus:
		m.ResetStatus()
		return nil
	case entcoupon.FieldReservedCount:
		m.ResetReservedCount()
		return nil
	}
	return fmt.Errorf("unknown Coupon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.currency != nil {
		edges = append(edges, entcoupon.EdgeCurrency)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entcoupon.EdgeCurrency:
		if id := m.currency; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcurrency {
		edges = append(edges, entcoupon.EdgeCurrency)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponMutation) EdgeCleared(name string) bool {
	switch name {
	case entcoupon.EdgeCurrency:
		return m.clearedcurrency
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponMutation) ClearEdge(name string) error {
	switch name {
	case entcoupon.EdgeCurrency:
		m.ClearCurrency()
		return nil
	}
	return fmt.Errorf("unknown Coupon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponMutation) ResetEdge(name string) error {
	switch name {
	case entcoupon.EdgeCurrency:
		m.ResetCurrency()
		return nil
	}
	return fmt.Errorf("unknown Coupon edge %s", name)
}

// CurrencyMutation represents an operation that mutates the Currency nodes in the graph.
type CurrencyMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	name              *string
	clearedFields     map[string]struct{}
	coupons           map[uint64]struct{}
	removedcoupons    map[uint64]struct{}
	clearedcoupons    bool
	milestones        map[uint64]struct{}
	removedmilestones map[uint64]struct{}
	clearedmilestones bool
	done              bool
	oldValue          func(context.Context) (*Currency, error)
	predicates        []predicate.Currency
}

var _ ent.Mutation = (*CurrencyMutation)(nil)

// currencyOption allows management of the mutation configuration using functional options.
type currencyOption func(*CurrencyMutation)

// newCurrencyMutation creates new mutation for the Currency entity.
func newCurrencyMutation(c config, op Op, opts ...currencyOption) *CurrencyMutation {
	m := &CurrencyMutation{
		config:        c,
		op:            op,
		typ:           TypeCurrency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCurrencyID sets the ID field of the mutation.
func withCurrencyID(id uint64) currencyOption {
	return func(m *CurrencyMutation) {
		var (
			err   error
			once  sync.Once
			value *Currency
		)
		m.oldValue = func(ctx context.Context) (*Currency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Currency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCurrency sets the old Currency of the mutation.
func withCurrency(node *Currency) currencyOption {
	return func(m *CurrencyMutation) {
		m.oldValue = func(context.Context) (*Currency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CurrencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CurrencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Currency entities.
func (m *CurrencyMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CurrencyMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CurrencyMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Currency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CurrencyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CurrencyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Currency entity.
// If the Currency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CurrencyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CurrencyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CurrencyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Currency entity.
// If the Currency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CurrencyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *CurrencyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CurrencyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Currency entity.
// If the Currency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CurrencyMutation) ResetName() {
	m.name = nil
}

// AddCouponIDs adds the "coupons" edge to the Coupon entity by ids.
func (m *CurrencyMutation) AddCouponIDs(ids ...uint64) {
	if m.coupons == nil {
		m.coupons = make(map[uint64]struct{})
	}
	for i := range ids {
		m.coupons[ids[i]] = struct{}{}
	}
}

// ClearCoupons clears the "coupons" edge to the Coupon entity.
func (m *CurrencyMutation) ClearCoupons() {
	m.clearedcoupons = true
}

// CouponsCleared reports if the "coupons" edge to the Coupon entity was cleared.
func (m *CurrencyMutation) CouponsCleared() bool {
	return m.clearedcoupons
}

// RemoveCouponIDs removes the "coupons" edge to the Coupon entity by IDs.
func (m *CurrencyMutation) RemoveCouponIDs(ids ...uint64) {
	if m.removedcoupons == nil {
		m.removedcoupons = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.coupons, ids[i])
		m.removedcoupons[ids[i]] = struct{}{}
	}
}

// RemovedCoupons returns the removed IDs of the "coupons" edge to the Coupon entity.
func (m *CurrencyMutation) RemovedCouponsIDs() (ids []uint64) {
	for id := range m.removedcoupons {
		ids = append(ids, id)
	}
	return
}

// CouponsIDs returns the "coupons" edge IDs in the mutation.
func (m *CurrencyMutation) CouponsIDs() (ids []uint64) {
	for id := range m.coupons {
		ids = append(ids, id)
	}
	return
}

// ResetCoupons resets all changes to the "coupons" edge.
func (m *CurrencyMutation) ResetCoupons() {
	m.coupons = nil
	m.clearedcoupons = false
	m.removedcoupons = nil
}

// AddMilestoneIDs adds the "milestones" edge to the Milestone entity by ids.
func (m *CurrencyMutation) AddMilestoneIDs(ids ...uint64) {
	if m.milestones == nil {
		m.milestones = make(map[uint64]struct{})
	}
	for i := range ids {
		m.milestones[ids[i]] = struct{}{}
	}
}

// ClearMilestones clears the "milestones" edge to the Milestone entity.
func (m *CurrencyMutation) ClearMilestones() {
	m.clearedmilestones = true
}

// MilestonesCleared reports if the "milestones" edge to the Milestone entity was cleared.
func (m *CurrencyMutation) MilestonesCleared() bool {
	return m.clearedmilestones
}

// RemoveMilestoneIDs removes the "milestones" edge to the Milestone entity by IDs.
func (m *CurrencyMutation) RemoveMilestoneIDs(ids ...uint64) {
	if m.removedmilestones == nil {
		m.removedmilestones = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.milestones, ids[i])
		m.removedmilestones[ids[i]] = struct{}{}
	}
}

// RemovedMilestones returns the removed IDs of the "milestones" edge to the Milestone entity.
func (m *CurrencyMutation) RemovedMilestonesIDs() (ids []uint64) {
	for id := range m.removedmilestones {
		ids = append(ids, id)
	}
	return
}

// MilestonesIDs returns the "milestones" edge IDs in the mutation.
func (m *CurrencyMutation) MilestonesIDs() (ids []uint64) {
	for id := range m.milestones {
		ids = append(ids, id)
	}
	return
}

// ResetMilestones resets all changes to the "milestones" edge.
func (m *CurrencyMutation) ResetMilestones() {
	m.milestones = nil
	m.clearedmilestones = false
	m.removedmilestones = nil
}

// Where appends a list predicates to the CurrencyMutation builder.
func (m *CurrencyMutation) Where(ps ...predicate.Currency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CurrencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CurrencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Currency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CurrencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CurrencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Currency).
func (m *CurrencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CurrencyMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, currency.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, currency.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, currency.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CurrencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case currency.FieldCreatedAt:
		return m.CreatedAt()
	case currency.FieldUpdatedAt:
		return m.UpdatedAt()
	case currency.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CurrencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case currency.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case currency.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case currency.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Currency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CurrencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case currency.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case currency.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case currency.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Currency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CurrencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CurrencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CurrencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Currency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CurrencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CurrencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CurrencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Currency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CurrencyMutation) ResetField(name string) error {
	switch name {
	case currency.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case currency.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case currency.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Currency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CurrencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.coupons != nil {
		edges = append(edges, currency.EdgeCoupons)
	}
	if m.milestones != nil {
		edges = append(edges, currency.EdgeMilestones)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CurrencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case currency.EdgeCoupons:
		ids := make([]ent.Value, 0, len(m.coupons))
		for id := range m.coupons {
			ids = append(ids, id)
		}
		return ids
	case currency.EdgeMilestones:
		ids := make([]ent.Value, 0, len(m.milestones))
		for id := range m.milestones {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CurrencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcoupons != nil {
		edges = append(edges, currency.EdgeCoupons)
	}
	if m.removedmilestones != nil {
		edges = append(edges, currency.EdgeMilestones)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CurrencyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case currency.EdgeCoupons:
		ids := make([]ent.Value, 0, len(m.removedcoupons))
		for id := range m.removedcoupons {
			ids = append(ids, id)
		}
		return ids
	case currency.EdgeMilestones:
		ids := make([]ent.Value, 0, len(m.removedmilestones))
		for id := range m.removedmilestones {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CurrencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcoupons {
		edges = append(edges, currency.EdgeCoupons)
	}
	if m.clearedmilestones {
		edges = append(edges, currency.EdgeMilestones)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CurrencyMutation) EdgeCleared(name string) bool {
	switch name {
	case currency.EdgeCoupons:
		return m.clearedcoupons
	case currency.EdgeMilestones:
		return m.clearedmilestones
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CurrencyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Currency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CurrencyMutation) ResetEdge(name string) error {
	switch name {
	case currency.EdgeCoupons:
		m.ResetCoupons()
		return nil
	case currency.EdgeMilestones:
		m.ResetMilestones()
		return nil
	}
	return fmt.Errorf("unknown Currency edge %s", name)
}

// MilestoneMutation represents an operation that mutates the Milestone nodes in the graph.
type MilestoneMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	name              *string
	store_id          *string
	expire_at         *time.Time
	service_ids       *[]string
	appendservice_ids []string
	coupon_type       *coupon.CouponType
	addcoupon_type    *coupon.CouponType
	milestone_type    *coupon.MilestoneType
	addmilestone_type *coupon.MilestoneType
	usage_limit       *int32
	addusage_limit    *int32
	threshold         *int32
	addthreshold      *int32
	step              *int32
	addstep           *int32
	coupon_value      *float64
	addcoupon_value   *float64
	clearedFields     map[string]struct{}
	currency          *uint64
	clearedcurrency   bool
	done              bool
	oldValue          func(context.Context) (*Milestone, error)
	predicates        []predicate.Milestone
}

var _ ent.Mutation = (*MilestoneMutation)(nil)

// milestoneOption allows management of the mutation configuration using functional options.
type milestoneOption func(*MilestoneMutation)

// newMilestoneMutation creates new mutation for the Milestone entity.
func newMilestoneMutation(c config, op Op, opts ...milestoneOption) *MilestoneMutation {
	m := &MilestoneMutation{
		config:        c,
		op:            op,
		typ:           TypeMilestone,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMilestoneID sets the ID field of the mutation.
func withMilestoneID(id uint64) milestoneOption {
	return func(m *MilestoneMutation) {
		var (
			err   error
			once  sync.Once
			value *Milestone
		)
		m.oldValue = func(ctx context.Context) (*Milestone, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Milestone.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMilestone sets the old Milestone of the mutation.
func withMilestone(node *Milestone) milestoneOption {
	return func(m *MilestoneMutation) {
		m.oldValue = func(context.Context) (*Milestone, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MilestoneMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MilestoneMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Milestone entities.
func (m *MilestoneMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MilestoneMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MilestoneMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Milestone.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MilestoneMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MilestoneMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Milestone entity.
// If the Milestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MilestoneMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MilestoneMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MilestoneMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MilestoneMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Milestone entity.
// If the Milestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MilestoneMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MilestoneMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *MilestoneMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MilestoneMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Milestone entity.
// If the Milestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MilestoneMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MilestoneMutation) ClearName() {
	m.name = nil
	m.clearedFields[milestone.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MilestoneMutation) NameCleared() bool {
	_, ok := m.clearedFields[milestone.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MilestoneMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, milestone.FieldName)
}

// SetStoreID sets the "store_id" field.
func (m *MilestoneMutation) SetStoreID(s string) {
	m.store_id = &s
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *MilestoneMutation) StoreID() (r string, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Milestone entity.
// If the Milestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MilestoneMutation) OldStoreID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *MilestoneMutation) ResetStoreID() {
	m.store_id = nil
}

// SetExpireAt sets the "expire_at" field.
func (m *MilestoneMutation) SetExpireAt(t time.Time) {
	m.expire_at = &t
}

// ExpireAt returns the value of the "expire_at" field in the mutation.
func (m *MilestoneMutation) ExpireAt() (r time.Time, exists bool) {
	v := m.expire_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireAt returns the old "expire_at" field's value of the Milestone entity.
// If the Milestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MilestoneMutation) OldExpireAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireAt: %w", err)
	}
	return oldValue.ExpireAt, nil
}

// ClearExpireAt clears the value of the "expire_at" field.
func (m *MilestoneMutation) ClearExpireAt() {
	m.expire_at = nil
	m.clearedFields[milestone.FieldExpireAt] = struct{}{}
}

// ExpireAtCleared returns if the "expire_at" field was cleared in this mutation.
func (m *MilestoneMutation) ExpireAtCleared() bool {
	_, ok := m.clearedFields[milestone.FieldExpireAt]
	return ok
}

// ResetExpireAt resets all changes to the "expire_at" field.
func (m *MilestoneMutation) ResetExpireAt() {
	m.expire_at = nil
	delete(m.clearedFields, milestone.FieldExpireAt)
}

// SetServiceIds sets the "service_ids" field.
func (m *MilestoneMutation) SetServiceIds(s []string) {
	m.service_ids = &s
	m.appendservice_ids = nil
}

// ServiceIds returns the value of the "service_ids" field in the mutation.
func (m *MilestoneMutation) ServiceIds() (r []string, exists bool) {
	v := m.service_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceIds returns the old "service_ids" field's value of the Milestone entity.
// If the Milestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MilestoneMutation) OldServiceIds(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceIds: %w", err)
	}
	return oldValue.ServiceIds, nil
}

// AppendServiceIds adds s to the "service_ids" field.
func (m *MilestoneMutation) AppendServiceIds(s []string) {
	m.appendservice_ids = append(m.appendservice_ids, s...)
}

// AppendedServiceIds returns the list of values that were appended to the "service_ids" field in this mutation.
func (m *MilestoneMutation) AppendedServiceIds() ([]string, bool) {
	if len(m.appendservice_ids) == 0 {
		return nil, false
	}
	return m.appendservice_ids, true
}

// ResetServiceIds resets all changes to the "service_ids" field.
func (m *MilestoneMutation) ResetServiceIds() {
	m.service_ids = nil
	m.appendservice_ids = nil
}

// SetCouponType sets the "coupon_type" field.
func (m *MilestoneMutation) SetCouponType(ct coupon.CouponType) {
	m.coupon_type = &ct
	m.addcoupon_type = nil
}

// CouponType returns the value of the "coupon_type" field in the mutation.
func (m *MilestoneMutation) CouponType() (r coupon.CouponType, exists bool) {
	v := m.coupon_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponType returns the old "coupon_type" field's value of the Milestone entity.
// If the Milestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MilestoneMutation) OldCouponType(ctx context.Context) (v coupon.CouponType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponType: %w", err)
	}
	return oldValue.CouponType, nil
}

// AddCouponType adds ct to the "coupon_type" field.
func (m *MilestoneMutation) AddCouponType(ct coupon.CouponType) {
	if m.addcoupon_type != nil {
		*m.addcoupon_type += ct
	} else {
		m.addcoupon_type = &ct
	}
}

// AddedCouponType returns the value that was added to the "coupon_type" field in this mutation.
func (m *MilestoneMutation) AddedCouponType() (r coupon.CouponType, exists bool) {
	v := m.addcoupon_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetCouponType resets all changes to the "coupon_type" field.
func (m *MilestoneMutation) ResetCouponType() {
	m.coupon_type = nil
	m.addcoupon_type = nil
}

// SetMilestoneType sets the "milestone_type" field.
func (m *MilestoneMutation) SetMilestoneType(ct coupon.MilestoneType) {
	m.milestone_type = &ct
	m.addmilestone_type = nil
}

// MilestoneType returns the value of the "milestone_type" field in the mutation.
func (m *MilestoneMutation) MilestoneType() (r coupon.MilestoneType, exists bool) {
	v := m.milestone_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMilestoneType returns the old "milestone_type" field's value of the Milestone entity.
// If the Milestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MilestoneMutation) OldMilestoneType(ctx context.Context) (v coupon.MilestoneType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMilestoneType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMilestoneType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMilestoneType: %w", err)
	}
	return oldValue.MilestoneType, nil
}

// AddMilestoneType adds ct to the "milestone_type" field.
func (m *MilestoneMutation) AddMilestoneType(ct coupon.MilestoneType) {
	if m.addmilestone_type != nil {
		*m.addmilestone_type += ct
	} else {
		m.addmilestone_type = &ct
	}
}

// AddedMilestoneType returns the value that was added to the "milestone_type" field in this mutation.
func (m *MilestoneMutation) AddedMilestoneType() (r coupon.MilestoneType, exists bool) {
	v := m.addmilestone_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetMilestoneType resets all changes to the "milestone_type" field.
func (m *MilestoneMutation) ResetMilestoneType() {
	m.milestone_type = nil
	m.addmilestone_type = nil
}

// SetCurrencyID sets the "currency_id" field.
func (m *MilestoneMutation) SetCurrencyID(u uint64) {
	m.currency = &u
}

// CurrencyID returns the value of the "currency_id" field in the mutation.
func (m *MilestoneMutation) CurrencyID() (r uint64, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrencyID returns the old "currency_id" field's value of the Milestone entity.
// If the Milestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MilestoneMutation) OldCurrencyID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrencyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrencyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrencyID: %w", err)
	}
	return oldValue.CurrencyID, nil
}

// ClearCurrencyID clears the value of the "currency_id" field.
func (m *MilestoneMutation) ClearCurrencyID() {
	m.currency = nil
	m.clearedFields[milestone.FieldCurrencyID] = struct{}{}
}

// CurrencyIDCleared returns if the "currency_id" field was cleared in this mutation.
func (m *MilestoneMutation) CurrencyIDCleared() bool {
	_, ok := m.clearedFields[milestone.FieldCurrencyID]
	return ok
}

// ResetCurrencyID resets all changes to the "currency_id" field.
func (m *MilestoneMutation) ResetCurrencyID() {
	m.currency = nil
	delete(m.clearedFields, milestone.FieldCurrencyID)
}

// SetUsageLimit sets the "usage_limit" field.
func (m *MilestoneMutation) SetUsageLimit(i int32) {
	m.usage_limit = &i
	m.addusage_limit = nil
}

// UsageLimit returns the value of the "usage_limit" field in the mutation.
func (m *MilestoneMutation) UsageLimit() (r int32, exists bool) {
	v := m.usage_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageLimit returns the old "usage_limit" field's value of the Milestone entity.
// If the Milestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MilestoneMutation) OldUsageLimit(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageLimit: %w", err)
	}
	return oldValue.UsageLimit, nil
}

// AddUsageLimit adds i to the "usage_limit" field.
func (m *MilestoneMutation) AddUsageLimit(i int32) {
	if m.addusage_limit != nil {
		*m.addusage_limit += i
	} else {
		m.addusage_limit = &i
	}
}

// AddedUsageLimit returns the value that was added to the "usage_limit" field in this mutation.
func (m *MilestoneMutation) AddedUsageLimit() (r int32, exists bool) {
	v := m.addusage_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageLimit resets all changes to the "usage_limit" field.
func (m *MilestoneMutation) ResetUsageLimit() {
	m.usage_limit = nil
	m.addusage_limit = nil
}

// SetThreshold sets the "threshold" field.
func (m *MilestoneMutation) SetThreshold(i int32) {
	m.threshold = &i
	m.addthreshold = nil
}

// Threshold returns the value of the "threshold" field in the mutation.
func (m *MilestoneMutation) Threshold() (r int32, exists bool) {
	v := m.threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldThreshold returns the old "threshold" field's value of the Milestone entity.
// If the Milestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MilestoneMutation) OldThreshold(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreshold: %w", err)
	}
	return oldValue.Threshold, nil
}

// AddThreshold adds i to the "threshold" field.
func (m *MilestoneMutation) AddThreshold(i int32) {
	if m.addthreshold != nil {
		*m.addthreshold += i
	} else {
		m.addthreshold = &i
	}
}

// AddedThreshold returns the value that was added to the "threshold" field in this mutation.
func (m *MilestoneMutation) AddedThreshold() (r int32, exists bool) {
	v := m.addthreshold
	if v == nil {
		return
	}
	return *v, true
}

// ResetThreshold resets all changes to the "threshold" field.
func (m *MilestoneMutation) ResetThreshold() {
	m.threshold = nil
	m.addthreshold = nil
}

// SetStep sets the "step" field.
func (m *MilestoneMutation) SetStep(i int32) {
	m.step = &i
	m.addstep = nil
}

// Step returns the value of the "step" field in the mutation.
func (m *MilestoneMutation) Step() (r int32, exists bool) {
	v := m.step
	if v == nil {
		return
	}
	return *v, true
}

// OldStep returns the old "step" field's value of the Milestone entity.
// If the Milestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MilestoneMutation) OldStep(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStep: %w", err)
	}
	return oldValue.Step, nil
}

// AddStep adds i to the "step" field.
func (m *MilestoneMutation) AddStep(i int32) {
	if m.addstep != nil {
		*m.addstep += i
	} else {
		m.addstep = &i
	}
}

// AddedStep returns the value that was added to the "step" field in this mutation.
func (m *MilestoneMutation) AddedStep() (r int32, exists bool) {
	v := m.addstep
	if v == nil {
		return
	}
	return *v, true
}

// ResetStep resets all changes to the "step" field.
func (m *MilestoneMutation) ResetStep() {
	m.step = nil
	m.addstep = nil
}

// SetCouponValue sets the "coupon_value" field.
func (m *MilestoneMutation) SetCouponValue(f float64) {
	m.coupon_value = &f
	m.addcoupon_value = nil
}

// CouponValue returns the value of the "coupon_value" field in the mutation.
func (m *MilestoneMutation) CouponValue() (r float64, exists bool) {
	v := m.coupon_value
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponValue returns the old "coupon_value" field's value of the Milestone entity.
// If the Milestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MilestoneMutation) OldCouponValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponValue: %w", err)
	}
	return oldValue.CouponValue, nil
}

// AddCouponValue adds f to the "coupon_value" field.
func (m *MilestoneMutation) AddCouponValue(f float64) {
	if m.addcoupon_value != nil {
		*m.addcoupon_value += f
	} else {
		m.addcoupon_value = &f
	}
}

// AddedCouponValue returns the value that was added to the "coupon_value" field in this mutation.
func (m *MilestoneMutation) AddedCouponValue() (r float64, exists bool) {
	v := m.addcoupon_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetCouponValue resets all changes to the "coupon_value" field.
func (m *MilestoneMutation) ResetCouponValue() {
	m.coupon_value = nil
	m.addcoupon_value = nil
}

// ClearCurrency clears the "currency" edge to the Currency entity.
func (m *MilestoneMutation) ClearCurrency() {
	m.clearedcurrency = true
	m.clearedFields[milestone.FieldCurrencyID] = struct{}{}
}

// CurrencyCleared reports if the "currency" edge to the Currency entity was cleared.
func (m *MilestoneMutation) CurrencyCleared() bool {
	return m.CurrencyIDCleared() || m.clearedcurrency
}

// CurrencyIDs returns the "currency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CurrencyID instead. It exists only for internal usage by the builders.
func (m *MilestoneMutation) CurrencyIDs() (ids []uint64) {
	if id := m.currency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCurrency resets all changes to the "currency" edge.
func (m *MilestoneMutation) ResetCurrency() {
	m.currency = nil
	m.clearedcurrency = false
}

// Where appends a list predicates to the MilestoneMutation builder.
func (m *MilestoneMutation) Where(ps ...predicate.Milestone) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MilestoneMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MilestoneMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Milestone, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MilestoneMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MilestoneMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Milestone).
func (m *MilestoneMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MilestoneMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, milestone.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, milestone.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, milestone.FieldName)
	}
	if m.store_id != nil {
		fields = append(fields, milestone.FieldStoreID)
	}
	if m.expire_at != nil {
		fields = append(fields, milestone.FieldExpireAt)
	}
	if m.service_ids != nil {
		fields = append(fields, milestone.FieldServiceIds)
	}
	if m.coupon_type != nil {
		fields = append(fields, milestone.FieldCouponType)
	}
	if m.milestone_type != nil {
		fields = append(fields, milestone.FieldMilestoneType)
	}
	if m.currency != nil {
		fields = append(fields, milestone.FieldCurrencyID)
	}
	if m.usage_limit != nil {
		fields = append(fields, milestone.FieldUsageLimit)
	}
	if m.threshold != nil {
		fields = append(fields, milestone.FieldThreshold)
	}
	if m.step != nil {
		fields = append(fields, milestone.FieldStep)
	}
	if m.coupon_value != nil {
		fields = append(fields, milestone.FieldCouponValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MilestoneMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case milestone.FieldCreatedAt:
		return m.CreatedAt()
	case milestone.FieldUpdatedAt:
		return m.UpdatedAt()
	case milestone.FieldName:
		return m.Name()
	case milestone.FieldStoreID:
		return m.StoreID()
	case milestone.FieldExpireAt:
		return m.ExpireAt()
	case milestone.FieldServiceIds:
		return m.ServiceIds()
	case milestone.FieldCouponType:
		return m.CouponType()
	case milestone.FieldMilestoneType:
		return m.MilestoneType()
	case milestone.FieldCurrencyID:
		return m.CurrencyID()
	case milestone.FieldUsageLimit:
		return m.UsageLimit()
	case milestone.FieldThreshold:
		return m.Threshold()
	case milestone.FieldStep:
		return m.Step()
	case milestone.FieldCouponValue:
		return m.CouponValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MilestoneMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case milestone.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case milestone.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case milestone.FieldName:
		return m.OldName(ctx)
	case milestone.FieldStoreID:
		return m.OldStoreID(ctx)
	case milestone.FieldExpireAt:
		return m.OldExpireAt(ctx)
	case milestone.FieldServiceIds:
		return m.OldServiceIds(ctx)
	case milestone.FieldCouponType:
		return m.OldCouponType(ctx)
	case milestone.FieldMilestoneType:
		return m.OldMilestoneType(ctx)
	case milestone.FieldCurrencyID:
		return m.OldCurrencyID(ctx)
	case milestone.FieldUsageLimit:
		return m.OldUsageLimit(ctx)
	case milestone.FieldThreshold:
		return m.OldThreshold(ctx)
	case milestone.FieldStep:
		return m.OldStep(ctx)
	case milestone.FieldCouponValue:
		return m.OldCouponValue(ctx)
	}
	return nil, fmt.Errorf("unknown Milestone field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MilestoneMutation) SetField(name string, value ent.Value) error {
	switch name {
	case milestone.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case milestone.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case milestone.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case milestone.FieldStoreID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case milestone.FieldExpireAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireAt(v)
		return nil
	case milestone.FieldServiceIds:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceIds(v)
		return nil
	case milestone.FieldCouponType:
		v, ok := value.(coupon.CouponType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponType(v)
		return nil
	case milestone.FieldMilestoneType:
		v, ok := value.(coupon.MilestoneType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMilestoneType(v)
		return nil
	case milestone.FieldCurrencyID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrencyID(v)
		return nil
	case milestone.FieldUsageLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageLimit(v)
		return nil
	case milestone.FieldThreshold:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreshold(v)
		return nil
	case milestone.FieldStep:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStep(v)
		return nil
	case milestone.FieldCouponValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponValue(v)
		return nil
	}
	return fmt.Errorf("unknown Milestone field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MilestoneMutation) AddedFields() []string {
	var fields []string
	if m.addcoupon_type != nil {
		fields = append(fields, milestone.FieldCouponType)
	}
	if m.addmilestone_type != nil {
		fields = append(fields, milestone.FieldMilestoneType)
	}
	if m.addusage_limit != nil {
		fields = append(fields, milestone.FieldUsageLimit)
	}
	if m.addthreshold != nil {
		fields = append(fields, milestone.FieldThreshold)
	}
	if m.addstep != nil {
		fields = append(fields, milestone.FieldStep)
	}
	if m.addcoupon_value != nil {
		fields = append(fields, milestone.FieldCouponValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MilestoneMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case milestone.FieldCouponType:
		return m.AddedCouponType()
	case milestone.FieldMilestoneType:
		return m.AddedMilestoneType()
	case milestone.FieldUsageLimit:
		return m.AddedUsageLimit()
	case milestone.FieldThreshold:
		return m.AddedThreshold()
	case milestone.FieldStep:
		return m.AddedStep()
	case milestone.FieldCouponValue:
		return m.AddedCouponValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MilestoneMutation) AddField(name string, value ent.Value) error {
	switch name {
	case milestone.FieldCouponType:
		v, ok := value.(coupon.CouponType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCouponType(v)
		return nil
	case milestone.FieldMilestoneType:
		v, ok := value.(coupon.MilestoneType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMilestoneType(v)
		return nil
	case milestone.FieldUsageLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageLimit(v)
		return nil
	case milestone.FieldThreshold:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThreshold(v)
		return nil
	case milestone.FieldStep:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStep(v)
		return nil
	case milestone.FieldCouponValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCouponValue(v)
		return nil
	}
	return fmt.Errorf("unknown Milestone numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MilestoneMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(milestone.FieldName) {
		fields = append(fields, milestone.FieldName)
	}
	if m.FieldCleared(milestone.FieldExpireAt) {
		fields = append(fields, milestone.FieldExpireAt)
	}
	if m.FieldCleared(milestone.FieldCurrencyID) {
		fields = append(fields, milestone.FieldCurrencyID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MilestoneMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MilestoneMutation) ClearField(name string) error {
	switch name {
	case milestone.FieldName:
		m.ClearName()
		return nil
	case milestone.FieldExpireAt:
		m.ClearExpireAt()
		return nil
	case milestone.FieldCurrencyID:
		m.ClearCurrencyID()
		return nil
	}
	return fmt.Errorf("unknown Milestone nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MilestoneMutation) ResetField(name string) error {
	switch name {
	case milestone.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case milestone.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case milestone.FieldName:
		m.ResetName()
		return nil
	case milestone.FieldStoreID:
		m.ResetStoreID()
		return nil
	case milestone.FieldExpireAt:
		m.ResetExpireAt()
		return nil
	case milestone.FieldServiceIds:
		m.ResetServiceIds()
		return nil
	case milestone.FieldCouponType:
		m.ResetCouponType()
		return nil
	case milestone.FieldMilestoneType:
		m.ResetMilestoneType()
		return nil
	case milestone.FieldCurrencyID:
		m.ResetCurrencyID()
		return nil
	case milestone.FieldUsageLimit:
		m.ResetUsageLimit()
		return nil
	case milestone.FieldThreshold:
		m.ResetThreshold()
		return nil
	case milestone.FieldStep:
		m.ResetStep()
		return nil
	case milestone.FieldCouponValue:
		m.ResetCouponValue()
		return nil
	}
	return fmt.Errorf("unknown Milestone field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MilestoneMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.currency != nil {
		edges = append(edges, milestone.EdgeCurrency)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MilestoneMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case milestone.EdgeCurrency:
		if id := m.currency; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MilestoneMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MilestoneMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MilestoneMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcurrency {
		edges = append(edges, milestone.EdgeCurrency)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MilestoneMutation) EdgeCleared(name string) bool {
	switch name {
	case milestone.EdgeCurrency:
		return m.clearedcurrency
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MilestoneMutation) ClearEdge(name string) error {
	switch name {
	case milestone.EdgeCurrency:
		m.ClearCurrency()
		return nil
	}
	return fmt.Errorf("unknown Milestone unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MilestoneMutation) ResetEdge(name string) error {
	switch name {
	case milestone.EdgeCurrency:
		m.ResetCurrency()
		return nil
	}
	return fmt.Errorf("unknown Milestone edge %s", name)
}
